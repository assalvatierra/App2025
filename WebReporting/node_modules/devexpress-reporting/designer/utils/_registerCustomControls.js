/**
* DevExpress HTML/JS Reporting (designer\utils\_registerCustomControls.js)
* Version:  24.2.5
* Build date: Feb 17, 2025
* Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { editorTypeMapper } from '@devexpress/analytics-core/analytics-internal';
import { ModelSerializer, colorFromString, colorToString, parseBool } from '@devexpress/analytics-core/analytics-utils';
import { editorTemplates } from '@devexpress/analytics-core/analytics-widgets';
import { CustomControlSerializableModel } from '../controls/customControlViewModel';
import { XRUnknownControlSurface } from '../controls/xrUnknownControl';
import { groups } from '../widgets/groups';
import { controlsFactory } from './settings';
export var ToolboxSubcategoriesGroups;
(function (ToolboxSubcategoriesGroups) {
    ToolboxSubcategoriesGroups[ToolboxSubcategoriesGroups["common"] = 0] = "common";
    ToolboxSubcategoriesGroups[ToolboxSubcategoriesGroups["graphics"] = 1] = "graphics";
    ToolboxSubcategoriesGroups[ToolboxSubcategoriesGroups["complex"] = 2] = "complex";
    ToolboxSubcategoriesGroups[ToolboxSubcategoriesGroups["misc"] = 3] = "misc";
    ToolboxSubcategoriesGroups[ToolboxSubcategoriesGroups["custom"] = 4] = "custom";
})(ToolboxSubcategoriesGroups || (ToolboxSubcategoriesGroups = {}));
export function registerCustomControls(controls) {
    if (!controls?.length) {
        return;
    }
    const factory = controlsFactory();
    controls.forEach((control) => {
        if (!factory.getControlInfo(control.className)) {
            const info = getSerializationInfo(control.properties, `${control.className}_`);
            const controlSubcategoryInfo = getControlInfo(control, factory);
            const meta = factory.inheritControl(control.inheritClassName, getMetaForControl(controlSubcategoryInfo, info));
            factory.registerControl(control.className, meta);
            info.forEach((prop) => {
                if (groups[prop.group] === undefined) {
                    groups[prop.group] = {
                        info: [prop],
                        displayName: () => prop.group,
                    };
                }
                else {
                    groups[prop.group].info.push(prop);
                }
            });
        }
    });
}
function getMetaForControl(controlInfo, info) {
    const control = controlInfo.control;
    const defaultVal = (control.initValues ?? []).reduce((result, current) => {
        result[current.Key] = current.Value;
        return result;
    }, {});
    const popularProperties = control.properties.filter(x => x.isFavorite).map(x => x.name);
    return {
        info,
        toolboxIndex: controlInfo.toolboxIndex,
        group: controlInfo.group,
        surfaceType: XRUnknownControlSurface,
        displayName: control.className,
        isToolboxItem: control.showInToolbox,
        popularProperties,
        defaultVal: {
            ...defaultVal,
            '@ControlType': control.fullTypeName,
        },
    };
}
function getSerializationInfo(properties, namePrefix = '') {
    return properties
        .map(prop => {
        const info = {
            propertyName: namePrefix + prop.name,
            modelName: prop.model,
            displayName: prop.displayName,
            group: prop.category,
            defaultVal: prop.defaultValue,
            ...getEditor(prop.editor)
        };
        if (prop.editor === 'enum') {
            const enumValues = prop?.values ?? [];
            info.valuesArray = enumValues;
        }
        if (prop.editor === 'object') {
            const objectProps = prop?.properties ?? [];
            info.from = (val, serializer) => CustomControlSerializableModel.from(val, serializer, getSerializationInfo(objectProps));
            info.toJsonObject = CustomControlSerializableModel.toJson;
        }
        if (prop.editor === 'array') {
            const arrayItemProps = prop?.properties ?? [];
            const propsInfo = getSerializationInfo(arrayItemProps);
            info.template = '#dxrd-commonCollectionItem';
            info.info = propsInfo;
            info.addHandler = () => CustomControlSerializableModel.from({}, new ModelSerializer(), propsInfo);
        }
        return info;
    });
}
function getEditor(name) {
    if (name === 'unknown') {
        return {};
    }
    if (name === 'boolean') {
        return { editor: editorTemplates.getEditor('boolSelect'), from: parseBool };
    }
    if (name === 'rationalNumber') {
        return { editor: editorTemplates.getEditor('numeric') };
    }
    if (name === 'irrationalNumber') {
        return { editor: editorTemplates.getEditor('numeric'), from: parseFloat };
    }
    if (name === 'enum') {
        return { editor: editorTemplates.getEditor('combobox') };
    }
    if (name === 'array') {
        return { editor: editorTemplates.getEditor('commonCollection'), array: true };
    }
    if (name === 'object') {
        return { editor: editorTemplates.getEditor('objecteditor') };
    }
    if (name === 'color') {
        return { editor: editorTemplates.getEditor('customColorEditor'), from: colorFromString, toJsonObject: colorToString };
    }
    if (name === 'link') {
        return { link: true };
    }
    const defaultEditor = editorTypeMapper[name] || editorTemplates.getEditor(name);
    if (defaultEditor) {
        return { editor: defaultEditor };
    }
    return {};
}
function getControlInfo(control, factory) {
    const controlsMap = Object.getOwnPropertyNames(factory.controlsMap)
        .map(control => factory.controlsMap[control]);
    let groupName;
    let customControlIndex;
    let toolboxSubcategoryPosition;
    if (control.xrToolboxSubcategory) {
        const toolboxSubcategoryGroupIndex = control.xrToolboxSubcategory.subcategory;
        toolboxSubcategoryPosition = control.xrToolboxSubcategory.position;
        groupName = ToolboxSubcategoriesGroups[toolboxSubcategoryGroupIndex];
    }
    if (groupName) {
        const customControlGroupIndexes = controlsMap
            .filter(control => control.group == groupName && control.toolboxIndex != undefined)
            .sort((a, b) => a.toolboxIndex - b.toolboxIndex);
        customControlIndex = !!customControlGroupIndexes[toolboxSubcategoryPosition] ?
            customControlGroupIndexes[toolboxSubcategoryPosition].toolboxIndex
            :
                customControlGroupIndexes[customControlGroupIndexes.length - 1].toolboxIndex + 1;
        controlsMap.forEach(control => {
            if (control.toolboxIndex >= customControlIndex)
                control.toolboxIndex++;
        });
    }
    else {
        const indexes = controlsMap.map(control => control.toolboxIndex).filter(toolboxIndex => toolboxIndex);
        customControlIndex = Math.max(...indexes) + 1;
        groupName = 'custom';
    }
    return {
        control: control,
        group: groupName,
        toolboxIndex: customControlIndex
    };
}
