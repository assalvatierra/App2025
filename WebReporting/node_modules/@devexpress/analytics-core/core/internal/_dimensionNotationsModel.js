/**
* DevExpress Analytics (core\internal\_dimensionNotationsModel.js)
* Version:  24.2.5
* Build date: Feb 17, 2025
* Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { convertFromCssPixelUnits } from './_utils.unitsConvertation';
import { getTemplate } from '../../property-grid/widgets/templateUtils';
import { pixelToUnits } from '../utils/_units.unitsToPixel';
import { getLocalization } from '../../property-grid/localization/_localization';
export class DimensionNotationsModel {
    constructor(_options) {
        this._options = _options;
        this.dHeight = ko.observable(0);
        this.dWidth = ko.observable(0);
    }
    renderTemplate(container) {
        const element = document.createElement('div');
        element.innerHTML = getTemplate('dxd-dimension-notations').trim();
        container.append(element);
        return element;
    }
    getFormattedString(value, measureUnit, zoom) {
        const size = pixelToUnits(value, measureUnit(), zoom());
        let result = '';
        switch (measureUnit()) {
            case 'HundredthsOfAnInch':
                const sizeInInches = (size / 100.0).toFixed(2);
                result = `${sizeInInches}″`;
                break;
            case 'TenthsOfAMillimeter':
                const sizeInMillimeters = (size / 10.0).toFixed(2);
                result = `${sizeInMillimeters} ${getLocalization('mm', 'PreviewStringId.Margin_Millimeter')}`;
                break;
            case 'Pixels':
            default:
                const sizeInPixels = size.toFixed(2);
                result = `${sizeInPixels} ${getLocalization('px', 'PreviewStringId.Margin_Pixel')}`;
                break;
        }
        return result;
    }
    start(container) {
        const { zoom, measureUnit } = this._options.surface();
        const controlModel = ko.dataFor(container)?.getControlModel?.();
        if (!this._options.enabled() || !controlModel) {
            this.cleanUp = () => { };
            return;
        }
        this.dHeight(0);
        this.dWidth(0);
        const initialWidth = convertFromCssPixelUnits(container.dataset.originalWidth);
        const initialHeight = convertFromCssPixelUnits(container.dataset.originalHeight);
        const width = ko.computed(() => this.getFormattedString(initialWidth + this.dWidth(), measureUnit, zoom));
        const height = ko.computed(() => this.getFormattedString(initialHeight + this.dHeight(), measureUnit, zoom));
        const isHAxisVisible = this._options.isHorizontalAxisVisible(controlModel);
        const isVAxisVisible = this._options.isVerticalAxisVisible(controlModel);
        const isLocatedInsideContainer = this._options.isLocatedInsideContainer(controlModel);
        const viewModel = {
            height,
            width,
            isHAxisVisible,
            isVAxisVisible,
            isLocatedInsideContainer,
        };
        const dnElement = this.renderTemplate(container);
        ko.applyBindings(viewModel, dnElement);
        this.cleanUp = () => {
            height.dispose();
            width.dispose();
            ko.cleanNode(dnElement);
            container?.removeChild(dnElement);
            container = null;
        };
    }
    stop() {
        this.cleanUp && this.cleanUp();
    }
    updateSize(boundsDiff) {
        this.dHeight(boundsDiff.height);
        this.dWidth(boundsDiff.width);
    }
}
