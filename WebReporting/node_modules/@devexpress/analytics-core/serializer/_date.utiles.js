/**
* DevExpress Analytics (serializer\_date.utiles.js)
* Version:  24.2.5
* Build date: Feb 17, 2025
* Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { DotnetTypes } from '../core/internal/_dotnetTypesMapper';
function toStringWithDelimiter(values, delimiter) {
    return (values || []).map(value => {
        let str = value !== undefined && value !== null ? value.toString() : '00';
        if (str.length === 1) {
            str = '0' + str;
        }
        return str;
    }).join(delimiter);
}
export function isDateType(type) {
    return [DotnetTypes.SystemDateTime, DotnetTypes.SystemDateOnly, DotnetTypes.SystemTimeOnly].some(x => x === type);
}
function formatMilliseconds(ms) {
    return (ms / 1000).toString().substring(1);
}
function normalizeMilliseconds(msString) {
    return msString && msString.padEnd(3, '0').substring(0, 3);
}
function _serializeDate(date, options) {
    const dateParts = options.utc ?
        [date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCFullYear()]
        : [date.getMonth() + 1, date.getDate(), date.getFullYear()];
    const timeParts = options.utc ?
        [date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()]
        : [date.getHours(), date.getMinutes(), date.getSeconds()];
    let timePartString = toStringWithDelimiter(timeParts, ':');
    if (options.type === DotnetTypes.SystemTimeOnly) {
        if (date.getMilliseconds() !== 0) {
            timePartString = timePartString + (options.utc ? formatMilliseconds(date.getUTCMilliseconds()) : formatMilliseconds(date.getMilliseconds()));
        }
        return timePartString;
    }
    const datePartString = toStringWithDelimiter([dateParts[2], dateParts[0], dateParts[1]], '-');
    if (timeParts.every(part => part === 0) || options.type === DotnetTypes.SystemDateOnly) {
        return datePartString;
    }
    if (options.delimiter === '-') {
        return datePartString + ' ' + timePartString;
    }
    return toStringWithDelimiter(dateParts, '/') + ' ' + timePartString;
}
export function _convertLocalDateToUTC(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
export function serializeDate(date, delimiter, type) {
    return _serializeDate(date, { delimiter, type });
}
export function serializeParameterDate(date, type) {
    return serializeDate(date, undefined, type);
}
export function serializeParameterDateUTC(date, type) {
    if ([DotnetTypes.SystemTimeOnly, DotnetTypes.SystemDateOnly, DotnetTypes.SystemDateTime].every(x => x !== type))
        return date;
    const utcDate = _convertLocalDateToUTC(date);
    if (type === DotnetTypes.SystemDateTime) {
        return utcDate;
    }
    return _serializeDate(utcDate, { type, utc: true });
}
export function parseTime(time) {
    if (!time)
        return null;
    if (time instanceof Date)
        return time;
    const [hoursPart, minutesPart, secondsPart = ''] = time.split(':');
    const [exactSecondsPart, millisecondsPart = ''] = secondsPart.split('.');
    const [hours, minutes, seconds, milliSeconds] = [hoursPart, minutesPart, exactSecondsPart, normalizeMilliseconds(millisecondsPart)].map(Number);
    const date = new Date();
    date.setHours(hours, minutes, seconds || 0, milliSeconds || 0);
    return date;
}
export function deserializeDate(dateTime) {
    const dateTimeParts = dateTime.split(' ');
    let dateArgs = dateTimeParts[0].split('-');
    let hours = 0, minutes = 0, seconds = 0, ms = 0;
    if (dateArgs.length !== 3) {
        dateArgs = dateTimeParts[0].split('/');
        dateArgs.splice(0, 0, dateArgs.splice(2, 1)[0]);
    }
    if (dateTimeParts.length > 1) {
        const timeParts = dateTimeParts[1].split(':');
        if (timeParts.length < 3)
            return null;
        hours = parseInt(timeParts[0]);
        minutes = parseInt(timeParts[1]);
        const [secondsPart = '', msPart = ''] = timeParts[2].split('.') ?? [];
        seconds = parseInt(secondsPart) || 0;
        ms = parseInt(normalizeMilliseconds(msPart)) || 0;
    }
    if (dateArgs.length !== 3)
        return null;
    dateArgs = dateArgs.map(x => parseInt(x));
    return new Date(dateArgs[0], dateArgs[1] - 1, dateArgs[2], hours, minutes, seconds, ms);
}
